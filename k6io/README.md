# Тестирование

## Нагрузочное тестирование

- ПО: https://k6.io/ и [скачать последнюю версию](https://dl.bintray.com/loadimpact/windows/k6-latest-amd64.msi)

## CLI

- `k6 run ./index.js --vus 100 --rps 50 --iterations 50 --out json=result.json -e VAARIABLE=value`
  - `vus` количество пользователей: 100
  - `iterations` количество итераций плана: 50
  - `rps` ограничение единовременных запросов в секунду между всеми vus
  - `out json=` - детальная трассировка лога запросов в файл (может вызвать проблемы с обеспечением заданных показателей rps)
  - `-e VaARIABLE=value` - установка собственных переменных среды

## Метрики

- vus текущее количество виртуальных пользователей

  Каждый виртуальный пользователь (`VU`) запускает файл теста в отдельном окружении, параллельно с остальными `VUs`. Код внутри функции эскпортированной как `default` являкется испольняемым кодом `VU`, и работает так долго, насколько это задачано планом теста. Код вне фукнкции default является инийциализирующим, и запускается единожды для каждого `VU` при запуске плана тестов.

- iterations Совокупное количество раз, когда `VU` в тесте выполнили скрипт `JS` ( defaultфункция). Или, если тест не использует JS-скрипт, а получает доступ к одному URL-адресу количество запросов, запрашиваемых этим VU-сервером.

- `http_req_duration`: общее время всего запроса
- `http_req_blocked`: время затраченное на блокировку (ожидание свободного слота TCP соедидения)
- `http_req_connecting`: время затраченнное на соединение по порту
- `http_req_receiving`: время получения ответа
- `http_req_sending`: время отправки запроса
- `http_req_tls_handshaking`: время на рукопожатие
- `http_req_waiting`: время ожидания ответа TTFB (Time To First Byte)

# План с изменением нагрузки

Данный пример демонстрирует каким образом можно создать план с изменяющейся нагрузкой. В этом случае стартовое количество виртуальных юзеров (vus) 5 в течении 3m изменяется до 10, затем 5 минут составляет 10 после этого 10 минут повышается до 35 и далее в течении 1 минуты 30 секунд опускается до 0

```js
export let options = {
  vus: 5,
  stages: [
    { duration: "3m", target: 10 },
    { duration: "5m", target: 10 },
    { duration: "10m", target: 35 },
    { duration: "1m30s", target: 0 }
  ]
};
```

Помимо прочего план можно запускать через CLI `--vus 5 --stage 3m:10,5m:10,10m:35,1m30s:0` или установить переменные среды `K6_VUS=5 K6_STAGE="3m:10,5m:10,10m:35,1m30s:0"` в итоге мы получим одинаковые результаты.

Концепция виртуальных пользователей подразумевает наличие в поведении некоторый элемент стохастических отклонений от заданного значения, это делает тесты более приближенными к реальности, если Вам надо жестко задать определенный порог нагрузки. то следует использтовать флаг `--rps`, который ограничивает нагруку жестко заданным значением запросов в секунду.

- **Внимание:** В случае если Вы запустили скрипт с трассировкой логов, то высока вероятность того, что рабочая машина не сможет обеспечить высокие значения rps, это связано с тем, что при включенной трассировке, каждый запрос логгируется в файл.
